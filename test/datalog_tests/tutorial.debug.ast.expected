typedef Address = Address{addr: ip_addr_t}
typedef Author = Author{name: string, born: ddlog_std::u32}
typedef BestDeal = BestDeal{best: string}
typedef BestPrice = BestPrice{item: string, price: bit<64>}
typedef BestVendor = BestVendor{item: string, vendor: string, price: bit<64>}
typedef Blacklisted = Blacklisted{ep: string}
typedef Book = Book{author: string, title: string}
typedef BookByAuthor = BookByAuthor{book: Book, author: Author}
typedef Bytes = Bytes{b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>}
typedef Category = CategoryStarWars{} |
                   CategoryOther{}
typedef Endpoint = Endpoint{ip: ip_addr_t, proto: string, preferred_port: bit<16>}
typedef EndpointString = EndpointString{s: string}
typedef Evens = Evens{evens_and_odds: ddlog_std::Vec<bigint>, evens: ddlog_std::Vec<bigint>}
typedef EvensAndOdds = EvensAndOdds{vec: ddlog_std::Vec<bigint>}
typedef First5 = First5{str: string}
typedef Flow = Flow{lr: bigint, stage: stage, prio: bigint, matchStr: string, actionStr: string}
typedef Flow1 = Flow1{lr: bigint, stage: stage, prio: bigint, matchStr: string, actionStr: string}
typedef Host = Host{id: UUID, name: string, ip: IP4}
typedef HostAddress = HostAddress{host: bit<64>, addrs: string}
typedef HostIP = HostIP{host: bit<64>, addr: string}
typedef HostIPVSep = HostIPVSep{host: bit<64>, addrs: string}
typedef HostInSubnet = HostInSubnet{host: UUID, subnet: UUID}
typedef IP4 = bit<32>
typedef IStoreItem = internment::Intern<StoreItem>
typedef IntranetHost = IntranetHost{addr: ip4_addr_t}
typedef IntranetHost2 = IntranetHost2{addr: ip4_addr_t}
typedef IntranetHost3 = IntranetHost3{addr: ip4_addr_t}
typedef InventoryItemName = InventoryItemName{name: string}
typedef ItemInOrders = ItemInOrders{item: string, orders: ddlog_std::Vec<ddlog_std::u64>}
typedef KnownHost = KnownHost{addr: ip4_addr_t}
typedef Library = Library{book: Book}
typedef Load_Balancer = Load_Balancer{lb: bigint, ls: bigint, ip_addresses: string, protocol: ddlog_std::Option<string>, name: string}
typedef Logical_Switch = Logical_Switch{ls: bigint}
typedef MCastAddress = MCastAddress{addr: ip_addr_t}
typedef MSetIn = MSetIn{x: ddlog_std::u32}
typedef MSetOut = MSetOut{x: ddlog_std::u32}
typedef MilkOrders = MilkOrders{order: ddlog_std::u64}
typedef NetHost = NetHost{id: bigint, h: nethost_t}
typedef NetHostString = NetHostString{id: bigint, s: string}
typedef NetMask = bit<32>
typedef Number = Number{n: bigint}
typedef OnlineOrder = OnlineOrder{order_id: ddlog_std::u64, item: internment::istring}
typedef OrderFormatted = OrderFormatted{order: string}
typedef Packet = Packet{pkt: eth_pkt_t}
typedef Person = Person{name: string, nationality: string, occupation: string}
typedef Phrases = Phrases{phrase: string}
typedef Pow2 = Pow2{p: string}
typedef Prefix = Prefix{vec: ddlog_std::Vec<string>}
typedef Price = Price{item: string, vendor: string, price: bit<64>}
typedef PriceInCents = PriceInCents{item: string, price1: ddlog_std::Option<ddlog_std::u64>, price2: ddlog_std::u64, price3: ddlog_std::Option<ddlog_std::u64>}
typedef Product = Product{x: bit<16>, y: bit<16>, prod: bit<16>}
typedef SanitizedEndpoint = SanitizedEndpoint{ep: string}
typedef School = School{name: string, address: string}
typedef StoreInventory = StoreInventory{item: IStoreItem}
typedef StoreItem = StoreItem{name: string, description: internment::istring}
typedef Student = Student{id: student_id, name: string, school: string, sat_score: bit<16>}
typedef StudentInfo = StudentInfo{student: ddlog_std::Ref<Student>, school: ddlog_std::Ref<School>}
typedef Subnet = Subnet{id: UUID, prefix: IP4, mask: NetMask}
typedef Sum = Sum{x: bit<16>, y: bit<16>, sum: bit<16>}
typedef TCPDstPort = TCPDstPort{port: bit<16>}
typedef TopScore = TopScore{school: string, top_score: bit<16>}
typedef UDPDstPort = UDPDstPort{port: bit<16>}
typedef UDPDstPort2 = UDPDstPort2{port: bit<16>}
typedef UUID = bit<128>
typedef Vector = Vector{vec: ddlog_std::Vec<string>, sep: string}
typedef Word1 = Word1{word: string, cat: Category}
typedef Word2 = Word2{word: string, cat: Category}
typedef WorstPrice = WorstPrice{item: string, price: bit<64>}
typedef X = X{x: bit<16>}
typedef ddlog_std::DDEpoch = ddlog_std::u64
typedef ddlog_std::DDIteration = ddlog_std::u64
typedef ddlog_std::DDNestedTS = ddlog_std::DDNestedTS{epoch: ddlog_std::DDEpoch, iter: ddlog_std::DDIteration}
typedef ddlog_std::DDWeight = ddlog_std::s64
typedef ddlog_std::Either<'A,'B> = ddlog_std::Left{l: 'A} |
                                   ddlog_std::Right{r: 'B}
extern type ddlog_std::Group<'K,'V>
extern type ddlog_std::Map<'K,'V>
#[rust = "serde(from=\"::std::option::Option<A>\", into=\"::std::option::Option<A>\", bound(serialize=\"A: Clone+Serialize\"))"]
#[custom_from_record = true]
typedef ddlog_std::Option<'A> = ddlog_std::None{} |
                                ddlog_std::Some{x: 'A}
#[size = 8]
#[shared_ref = true]
extern type ddlog_std::Ref<'A>
typedef ddlog_std::Result<'V,'E> = ddlog_std::Ok{res: 'V} |
                                   ddlog_std::Err{err: 'E}
extern type ddlog_std::Set<'A>
extern type ddlog_std::Vec<'A>
typedef ddlog_std::s128 = signed<128>
typedef ddlog_std::s16 = signed<16>
typedef ddlog_std::s32 = signed<32>
typedef ddlog_std::s64 = signed<64>
typedef ddlog_std::s8 = signed<8>
#[alias = true]
typedef ddlog_std::u128 = bit<128>
#[alias = true]
typedef ddlog_std::u16 = bit<16>
#[alias = true]
typedef ddlog_std::u32 = bit<32>
#[alias = true]
typedef ddlog_std::u64 = bit<64>
#[alias = true]
typedef ddlog_std::u8 = bit<8>
#[alias = true]
typedef ddlog_std::usize = bit<64>
typedef debug::DDlogOpId = (ddlog_std::u32, ddlog_std::u32, ddlog_std::u32)
typedef eth_payload_t = EthIP4{ip4: ip4_pkt_t} |
                        EthIP6{ip6: ip6_pkt_t} |
                        EthOther{}
typedef eth_pkt_t = EthPacket{src: bit<48>, dst: bit<48>, payload: eth_payload_t}
#[size = 8]
#[shared_ref = true]
extern type internment::Intern<'A>
typedef internment::istring = internment::Intern<string>
typedef ip4_addr_t = bit<32>
typedef ip4_pkt_t = IP4Pkt{ttl: bit<8>, src: ip4_addr_t, dst: ip4_addr_t, payload: ip_payload_t}
typedef ip6_addr_t = bit<128>
typedef ip6_pkt_t = IP6Pkt{ttl: bit<8>, src: ip6_addr_t, dst: ip6_addr_t, payload: ip_payload_t}
typedef ip_addr_t = IPAddr{addr: bit<32>}
typedef ip_payload_t = IPTCP{tcp: tcp_pkt_t} |
                       IPUDP{udp: udp_pkt_t} |
                       IPOther{}
typedef log::log_level_t = signed<32>
typedef log::module_t = signed<32>
typedef mac_addr_t = MACAddr{addr: bit<48>}
typedef nethost_t = NHost{ip: ip_addr_t, mac: mac_addr_t}
typedef stage = LS_IN_PRE_LB{} |
                LS_OUT_PRE_LB{}
typedef student_id = bit<64>
typedef tcp_pkt_t = TCPPkt{src: bit<16>, dst: bit<16>, flags: bit<9>}
typedef udp_pkt_t = UDPPkt{src: bit<16>, dst: bit<16>, len: bit<16>}
function __debug_19_1_best_vendor (g: ddlog_std::Group<string,('I, (string, bit<64>))>): (ddlog_std::Vec<'I>, (string, bit<64>))
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,(string, bit<64>)>)) = debug::debug_split_group(g);
     (inputs, best_vendor(original_group))}
}
function __debug_20_2_best_vendor_string (g: ddlog_std::Group<string,('I, (string, bit<64>))>): (ddlog_std::Vec<'I>, string)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,(string, bit<64>)>)) = debug::debug_split_group(g);
     (inputs, best_vendor_string(original_group))}
}
function addr_port (ip: ip_addr_t, proto: string, preferred_port: bit<16>): string
{
    {(var port: bit<16>) = match (proto) {
                               "FTP" -> 16'd20,
                               "HTTPS" -> 16'd443,
                               (_: string) -> if (preferred_port != 16'd0) {
                                                  preferred_port
                                              } else {
                                                    ((return (("" ++ (to_string(ip): string)) ++ ":80")): bit<16>)
                                                }
                           };
     ((("" ++ (to_string(ip): string)) ++ ":") ++ (ddlog_std::__builtin_2string(port): string))}
}
function addr_to_tuple (addr: ip4_addr_t): (bit<8>, bit<8>, bit<8>, bit<8>)
{
    (addr[31:24], addr[23:16], addr[15:8], addr[7:0])
}
function best_vendor (g: ddlog_std::Group<'K,(string, bit<64>)>): (string, bit<64>)
{
    {(var min_vendor: string) = "";
     {(var min_price: bit<64>) = 64'd18446744073709551615;
      {for (vendor_price in g) {
           if (vendor_price.1 < min_price) {
               {min_vendor = vendor_price.0;
                {min_price = vendor_price.1;
                 ()}}
           } else {
                 ()
             }
       };
       (min_vendor, min_price)}}}
}
function best_vendor_string (g: ddlog_std::Group<string,(string, bit<64>)>): string
{
    {(var min_vendor: string) = "";
     {(var min_price: bit<64>) = 64'd18446744073709551615;
      {for (vendor_price in g) {
           if (vendor_price.1 < min_price) {
               {min_vendor = vendor_price.0;
                {min_price = vendor_price.1;
                 ()}}
           } else {
                 ()
             }
       };
       ((((("Best deal for " ++ (ddlog_std::group_key(g): string)) ++ ": ") ++ min_vendor) ++ ", $") ++ (ddlog_std::__builtin_2string(min_price): string))}}}
}
extern function ddlog_std::__builtin_2string (x: 'X): string
function ddlog_std::__debug_17_1_group_min (g: ddlog_std::Group<string,('I, bit<64>)>): (ddlog_std::Vec<'I>, bit<64>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<64>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_min(original_group))}
}
function ddlog_std::__debug_18_1_group_max (g: ddlog_std::Group<string,('I, bit<64>)>): (ddlog_std::Vec<'I>, bit<64>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<64>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_max(original_group))}
}
function ddlog_std::__debug_33_1_group_max (g: ddlog_std::Group<string,('I, bit<16>)>): (ddlog_std::Vec<'I>, bit<16>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<16>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_max(original_group))}
}
function ddlog_std::__debug_34_1_group_max (g: ddlog_std::Group<string,('I, bit<16>)>): (ddlog_std::Vec<'I>, bit<16>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<16>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_max(original_group))}
}
function ddlog_std::__debug_35_1_group_to_vec (g: ddlog_std::Group<internment::Intern<string>,('I, bit<64>)>): (ddlog_std::Vec<'I>, ddlog_std::Vec<bit<64>>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<internment::Intern<string>,bit<64>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_to_vec(original_group))}
}
function ddlog_std::append (v: mut ddlog_std::Vec<'X>, other: ddlog_std::Vec<'X>): ()
{
    ddlog_std::vec_append(v, other)
}
extern function ddlog_std::bigint_pow32 (base: bigint, exp: bit<32>): bigint
function ddlog_std::contains (s1: string, s2: string): bool
{
    ddlog_std::string_contains(s1, s2)
}
function ddlog_std::contains (v: ddlog_std::Vec<'X>, x: 'X): bool
{
    ddlog_std::vec_contains(v, x)
}
function ddlog_std::contains (s: ddlog_std::Set<'X>, v: 'X): bool
{
    ddlog_std::set_contains(s, v)
}
function ddlog_std::contains_key (m: ddlog_std::Map<'K,'V>, k: 'K): bool
{
    ddlog_std::map_contains_key(m, k)
}
function ddlog_std::count (g: ddlog_std::Group<'K,'V>): ddlog_std::usize
{
    ddlog_std::group_count(g)
}
extern function ddlog_std::default (): 'T
#[return_by_ref = true]
extern function ddlog_std::deref (x: ddlog_std::Ref<'A>): 'A
function ddlog_std::difference (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
{
    (ddlog_std::set_difference(s1, s2): ddlog_std::Set<'X>)
}
function ddlog_std::ends_with (s: string, suffix: string): bool
{
    ddlog_std::string_ends_with(s, suffix)
}
function ddlog_std::first (g: ddlog_std::Group<'K,'V>): 'V
{
    (ddlog_std::group_first(g): 'V)
}
function ddlog_std::get (m: ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
{
    (ddlog_std::map_get(m, k): ddlog_std::Option<'V>)
}
extern function ddlog_std::group_count (g: ddlog_std::Group<'K,'V>): ddlog_std::usize
extern function ddlog_std::group_first (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_key (g: ddlog_std::Group<'K,'V>): 'K
extern function ddlog_std::group_max (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_min (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_nth (g: ddlog_std::Group<'K,'V>, n: ddlog_std::usize): ddlog_std::Option<'V>
extern function ddlog_std::group_set_unions (g: ddlog_std::Group<'K,ddlog_std::Set<'A>>): ddlog_std::Set<'A>
extern function ddlog_std::group_setref_unions (g: ddlog_std::Group<'K,ddlog_std::Ref<ddlog_std::Set<'A>>>): ddlog_std::Ref<ddlog_std::Set<'A>>
extern function ddlog_std::group_sum (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_to_map (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,'V>
extern function ddlog_std::group_to_set (g: ddlog_std::Group<'K,'V>): ddlog_std::Set<'V>
extern function ddlog_std::group_to_setmap (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,ddlog_std::Set<'V>>
extern function ddlog_std::group_to_vec (g: ddlog_std::Group<'K,'V>): ddlog_std::Vec<'V>
function ddlog_std::group_unzip (g: ddlog_std::Group<'K,('X, 'Y)>): (ddlog_std::Vec<'X>, ddlog_std::Vec<'Y>)
{
    {(var xs: ddlog_std::Vec<'X>) = (ddlog_std::vec_empty(): ddlog_std::Vec<'X>);
     {(var ys: ddlog_std::Vec<'Y>) = (ddlog_std::vec_empty(): ddlog_std::Vec<'Y>);
      {for (v in g) {
           {((var x: 'X), (var y: 'Y)) = v;
            {ddlog_std::vec_push(xs, x);
             ddlog_std::vec_push(ys, y)}}
       };
       (xs, ys)}}}
}
extern function ddlog_std::hash128 (x: 'X): bit<128>
extern function ddlog_std::hash64 (x: 'X): bit<64>
extern function ddlog_std::hex (x: 'X): string
extern function ddlog_std::htonl (x: bit<32>): bit<32>
extern function ddlog_std::htons (x: bit<16>): bit<16>
function ddlog_std::insert (m: mut ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ()
{
    ddlog_std::map_insert(m, k, v)
}
function ddlog_std::insert (s: mut ddlog_std::Set<'X>, v: 'X): ()
{
    ddlog_std::set_insert(s, v)
}
function ddlog_std::insert_imm (m: ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ddlog_std::Map<'K,'V>
{
    (ddlog_std::map_insert_imm(m, k, v): ddlog_std::Map<'K,'V>)
}
function ddlog_std::insert_imm (s: ddlog_std::Set<'X>, v: 'X): ddlog_std::Set<'X>
{
    (ddlog_std::set_insert_imm(s, v): ddlog_std::Set<'X>)
}
function ddlog_std::intersection (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
{
    (ddlog_std::set_intersection(s1, s2): ddlog_std::Set<'X>)
}
function ddlog_std::is_empty (v: ddlog_std::Vec<'X>): bool
{
    ddlog_std::vec_is_empty(v)
}
function ddlog_std::is_empty (m: ddlog_std::Map<'K,'V>): bool
{
    ddlog_std::map_is_empty(m)
}
function ddlog_std::is_empty (s: ddlog_std::Set<'X>): bool
{
    ddlog_std::set_is_empty(s)
}
function ddlog_std::is_err (res: ddlog_std::Result<'V,'E>): bool
{
    match (res) {
        (ddlog_std::Ok{.res=(_: 'V)}: ddlog_std::Result<'V,'E>) -> false,
        (ddlog_std::Err{.err=(_: 'E)}: ddlog_std::Result<'V,'E>) -> true
    }
}
function ddlog_std::is_none (x: ddlog_std::Option<'A>): bool
{
    match (x) {
        (ddlog_std::None{}: ddlog_std::Option<'A>) -> true,
        (_: ddlog_std::Option<'A>) -> false
    }
}
function ddlog_std::is_ok (res: ddlog_std::Result<'V,'E>): bool
{
    match (res) {
        (ddlog_std::Ok{.res=(_: 'V)}: ddlog_std::Result<'V,'E>) -> true,
        (ddlog_std::Err{.err=(_: 'E)}: ddlog_std::Result<'V,'E>) -> false
    }
}
function ddlog_std::is_some (x: ddlog_std::Option<'A>): bool
{
    match (x) {
        (ddlog_std::Some{.x=(_: 'A)}: ddlog_std::Option<'A>) -> true,
        (_: ddlog_std::Option<'A>) -> false
    }
}
function ddlog_std::join (strings: ddlog_std::Vec<string>, sep: string): string
{
    ddlog_std::string_join(strings, sep)
}
function ddlog_std::key (g: ddlog_std::Group<'K,'V>): 'K
{
    (ddlog_std::group_key(g): 'K)
}
function ddlog_std::keys (m: ddlog_std::Map<'K,'V>): ddlog_std::Vec<'K>
{
    (ddlog_std::map_keys(m): ddlog_std::Vec<'K>)
}
function ddlog_std::len (s: string): ddlog_std::usize
{
    ddlog_std::string_len(s)
}
function ddlog_std::len (v: ddlog_std::Vec<'X>): ddlog_std::usize
{
    ddlog_std::vec_len(v)
}
extern function ddlog_std::map_contains_key (m: ddlog_std::Map<'K,'V>, k: 'K): bool
extern function ddlog_std::map_empty (): ddlog_std::Map<'K,'V>
extern function ddlog_std::map_get (m: ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
extern function ddlog_std::map_insert (m: mut ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ()
extern function ddlog_std::map_insert_imm (m: ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ddlog_std::Map<'K,'V>
extern function ddlog_std::map_is_empty (m: ddlog_std::Map<'K,'V>): bool
extern function ddlog_std::map_keys (m: ddlog_std::Map<'K,'V>): ddlog_std::Vec<'K>
extern function ddlog_std::map_remove (m: mut ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
extern function ddlog_std::map_singleton (k: 'K, v: 'V): ddlog_std::Map<'K,'V>
extern function ddlog_std::map_size (m: ddlog_std::Map<'K,'V>): ddlog_std::usize
extern function ddlog_std::map_union (m1: ddlog_std::Map<'K,'V>, m2: ddlog_std::Map<'K,'V>): ddlog_std::Map<'K,'V>
function ddlog_std::max (x: 'A, y: 'A): 'A
{
    if (x > y) {
        x
    } else {
          y
      }
}
function ddlog_std::max (g: ddlog_std::Group<'K,'V>): 'V
{
    (ddlog_std::group_max(g): 'V)
}
function ddlog_std::min (x: 'A, y: 'A): 'A
{
    if (x < y) {
        x
    } else {
          y
      }
}
function ddlog_std::min (g: ddlog_std::Group<'K,'V>): 'V
{
    (ddlog_std::group_min(g): 'V)
}
function ddlog_std::nth (g: ddlog_std::Group<'K,'V>, n: ddlog_std::usize): ddlog_std::Option<'V>
{
    (ddlog_std::group_nth(g, n): ddlog_std::Option<'V>)
}
function ddlog_std::nth (v: ddlog_std::Vec<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
{
    (ddlog_std::vec_nth(v, n): ddlog_std::Option<'X>)
}
function ddlog_std::nth (s: ddlog_std::Set<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
{
    (ddlog_std::set_nth(s, n): ddlog_std::Option<'X>)
}
extern function ddlog_std::ntohl (x: bit<32>): bit<32>
extern function ddlog_std::ntohs (x: bit<16>): bit<16>
extern function ddlog_std::option_unwrap_or_default (opt: ddlog_std::Option<'A>): 'A
extern function ddlog_std::parse_dec_i64 (s: string): ddlog_std::Option<signed<64>>
extern function ddlog_std::parse_dec_u64 (s: string): ddlog_std::Option<bit<64>>
function ddlog_std::pow32 (base: ddlog_std::u8, exp: bit<32>): ddlog_std::u8
{
    ddlog_std::u8_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u16, exp: bit<32>): ddlog_std::u16
{
    ddlog_std::u16_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u32, exp: bit<32>): ddlog_std::u32
{
    ddlog_std::u32_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u64, exp: bit<32>): ddlog_std::u64
{
    ddlog_std::u64_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u128, exp: bit<32>): ddlog_std::u128
{
    ddlog_std::u128_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s8, exp: bit<32>): ddlog_std::s8
{
    ddlog_std::s8_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s16, exp: bit<32>): ddlog_std::s16
{
    ddlog_std::s16_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s32, exp: bit<32>): ddlog_std::s32
{
    ddlog_std::s32_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s64, exp: bit<32>): ddlog_std::s64
{
    ddlog_std::s64_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s128, exp: bit<32>): ddlog_std::s128
{
    ddlog_std::s128_pow32(base, exp)
}
function ddlog_std::pow32 (base: bigint, exp: bit<32>): bigint
{
    ddlog_std::bigint_pow32(base, exp)
}
function ddlog_std::push (v: mut ddlog_std::Vec<'X>, x: 'X): ()
{
    ddlog_std::vec_push(v, x)
}
function ddlog_std::push_imm (v: ddlog_std::Vec<'X>, x: 'X): ddlog_std::Vec<'X>
{
    (ddlog_std::vec_push_imm(v, x): ddlog_std::Vec<'X>)
}
extern function ddlog_std::range (from: 'A, to: 'A, step: 'A): ddlog_std::Vec<'A>
extern function ddlog_std::ref_new (x: 'A): ddlog_std::Ref<'A>
function ddlog_std::remove (m: mut ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
{
    (ddlog_std::map_remove(m, k): ddlog_std::Option<'V>)
}
function ddlog_std::replace (s: string, from: string, to: string): string
{
    ddlog_std::string_replace(s, from, to)
}
function ddlog_std::resize (v: mut ddlog_std::Vec<'X>, new_len: ddlog_std::usize, value: 'X): ()
{
    ddlog_std::vec_resize(v, new_len, value)
}
extern function ddlog_std::result_unwrap_or_default (res: ddlog_std::Result<'V,'E>): 'V
function ddlog_std::reverse (s: string): string
{
    ddlog_std::string_reverse(s)
}
extern function ddlog_std::s128_pow32 (base: ddlog_std::s128, exp: bit<32>): ddlog_std::s128
extern function ddlog_std::s16_pow32 (base: ddlog_std::s16, exp: bit<32>): ddlog_std::s16
extern function ddlog_std::s32_pow32 (base: ddlog_std::s32, exp: bit<32>): ddlog_std::s32
extern function ddlog_std::s64_pow32 (base: ddlog_std::s64, exp: bit<32>): ddlog_std::s64
extern function ddlog_std::s8_pow32 (base: ddlog_std::s8, exp: bit<32>): ddlog_std::s8
extern function ddlog_std::set_contains (s: ddlog_std::Set<'X>, v: 'X): bool
extern function ddlog_std::set_difference (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
extern function ddlog_std::set_empty (): ddlog_std::Set<'X>
extern function ddlog_std::set_insert (s: mut ddlog_std::Set<'X>, v: 'X): ()
extern function ddlog_std::set_insert_imm (s: ddlog_std::Set<'X>, v: 'X): ddlog_std::Set<'X>
extern function ddlog_std::set_intersection (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
extern function ddlog_std::set_is_empty (s: ddlog_std::Set<'X>): bool
extern function ddlog_std::set_nth (s: ddlog_std::Set<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
extern function ddlog_std::set_singleton (x: 'X): ddlog_std::Set<'X>
extern function ddlog_std::set_size (s: ddlog_std::Set<'X>): ddlog_std::usize
extern function ddlog_std::set_to_vec (s: ddlog_std::Set<'A>): ddlog_std::Vec<'A>
extern function ddlog_std::set_union (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
extern function ddlog_std::set_unions (sets: ddlog_std::Vec<ddlog_std::Set<'X>>): ddlog_std::Set<'X>
function ddlog_std::setref_unions (g: ddlog_std::Group<'K,ddlog_std::Ref<ddlog_std::Set<'A>>>): ddlog_std::Ref<ddlog_std::Set<'A>>
{
    (ddlog_std::group_setref_unions(g): ddlog_std::Ref<ddlog_std::Set<'A>>)
}
function ddlog_std::size (m: ddlog_std::Map<'K,'V>): ddlog_std::usize
{
    ddlog_std::map_size(m)
}
function ddlog_std::size (s: ddlog_std::Set<'X>): ddlog_std::usize
{
    ddlog_std::set_size(s)
}
function ddlog_std::sort (v: mut ddlog_std::Vec<'X>): ()
{
    ddlog_std::vec_sort(v)
}
function ddlog_std::sort_imm (v: ddlog_std::Vec<'X>): ddlog_std::Vec<'X>
{
    (ddlog_std::vec_sort_imm(v): ddlog_std::Vec<'X>)
}
function ddlog_std::split (s: string, sep: string): ddlog_std::Vec<string>
{
    ddlog_std::string_split(s, sep)
}
function ddlog_std::starts_with (s: string, prefix: string): bool
{
    ddlog_std::string_starts_with(s, prefix)
}
extern function ddlog_std::str_to_lower (s: string): string
extern function ddlog_std::string_contains (s1: string, s2: string): bool
extern function ddlog_std::string_ends_with (s: string, suffix: string): bool
extern function ddlog_std::string_join (strings: ddlog_std::Vec<string>, sep: string): string
extern function ddlog_std::string_len (s: string): ddlog_std::usize
extern function ddlog_std::string_replace (s: string, from: string, to: string): string
extern function ddlog_std::string_reverse (s: string): string
extern function ddlog_std::string_split (s: string, sep: string): ddlog_std::Vec<string>
extern function ddlog_std::string_starts_with (s: string, prefix: string): bool
extern function ddlog_std::string_substr (s: string, start: ddlog_std::usize, end: ddlog_std::usize): string
extern function ddlog_std::string_to_bytes (s: string): ddlog_std::Vec<ddlog_std::u8>
extern function ddlog_std::string_to_lowercase (s: string): string
extern function ddlog_std::string_to_uppercase (s: string): string
extern function ddlog_std::string_trim (s: string): string
function ddlog_std::substr (s: string, start: ddlog_std::usize, end: ddlog_std::usize): string
{
    ddlog_std::string_substr(s, start, end)
}
function ddlog_std::swap_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: mut 'X): bool
{
    ddlog_std::vec_swap_nth(v, idx, value)
}
function ddlog_std::to_bytes (s: string): ddlog_std::Vec<ddlog_std::u8>
{
    ddlog_std::string_to_bytes(s)
}
function ddlog_std::to_lowercase (s: string): string
{
    ddlog_std::string_to_lowercase(s)
}
function ddlog_std::to_map (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,'V>
{
    (ddlog_std::group_to_map(g): ddlog_std::Map<'K2,'V>)
}
function ddlog_std::to_set (o: ddlog_std::Option<'X>): ddlog_std::Set<'X>
{
    match (o) {
        (ddlog_std::Some{.x=(var x: 'X)}: ddlog_std::Option<'X>) -> (ddlog_std::set_singleton(x): ddlog_std::Set<'X>),
        (ddlog_std::None{}: ddlog_std::Option<'X>) -> (ddlog_std::set_empty(): ddlog_std::Set<'X>)
    }
}
function ddlog_std::to_set (g: ddlog_std::Group<'K,'V>): ddlog_std::Set<'V>
{
    (ddlog_std::group_to_set(g): ddlog_std::Set<'V>)
}
function ddlog_std::to_set (s: ddlog_std::Vec<'A>): ddlog_std::Set<'A>
{
    (ddlog_std::vec_to_set(s): ddlog_std::Set<'A>)
}
function ddlog_std::to_setmap (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,ddlog_std::Set<'V>>
{
    (ddlog_std::group_to_setmap(g): ddlog_std::Map<'K2,ddlog_std::Set<'V>>)
}
function ddlog_std::to_string (ts: ddlog_std::DDNestedTS): string
{
    (((("(" ++ (ddlog_std::__builtin_2string(ts.epoch): string)) ++ ",") ++ (ddlog_std::__builtin_2string(ts.iter): string)) ++ ")")
}
function ddlog_std::to_string (x: bool): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: bigint): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: float): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: double): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::s8): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::s16): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::s32): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::s64): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::s128): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::u8): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::u16): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::u32): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::u64): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: ddlog_std::u128): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_string (x: string): string
{
    ddlog_std::__builtin_2string(x)
}
function ddlog_std::to_uppercase (s: string): string
{
    ddlog_std::string_to_uppercase(s)
}
function ddlog_std::to_vec (o: ddlog_std::Option<'X>): ddlog_std::Vec<'X>
{
    match (o) {
        (ddlog_std::Some{.x=(var x: 'X)}: ddlog_std::Option<'X>) -> (ddlog_std::vec_singleton(x): ddlog_std::Vec<'X>),
        (ddlog_std::None{}: ddlog_std::Option<'X>) -> (ddlog_std::vec_empty(): ddlog_std::Vec<'X>)
    }
}
function ddlog_std::to_vec (g: ddlog_std::Group<'K,'V>): ddlog_std::Vec<'V>
{
    (ddlog_std::group_to_vec(g): ddlog_std::Vec<'V>)
}
function ddlog_std::to_vec (s: ddlog_std::Set<'A>): ddlog_std::Vec<'A>
{
    (ddlog_std::set_to_vec(s): ddlog_std::Vec<'A>)
}
function ddlog_std::trim (s: string): string
{
    ddlog_std::string_trim(s)
}
extern function ddlog_std::u128_pow32 (base: ddlog_std::u128, exp: bit<32>): ddlog_std::u128
extern function ddlog_std::u16_pow32 (base: ddlog_std::u16, exp: bit<32>): ddlog_std::u16
extern function ddlog_std::u32_pow32 (base: ddlog_std::u32, exp: bit<32>): ddlog_std::u32
extern function ddlog_std::u64_pow32 (base: ddlog_std::u64, exp: bit<32>): ddlog_std::u64
extern function ddlog_std::u8_pow32 (base: ddlog_std::u8, exp: bit<32>): ddlog_std::u8
function ddlog_std::union (m1: ddlog_std::Map<'K,'V>, m2: ddlog_std::Map<'K,'V>): ddlog_std::Map<'K,'V>
{
    (ddlog_std::map_union(m1, m2): ddlog_std::Map<'K,'V>)
}
function ddlog_std::union (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
{
    (ddlog_std::set_union(s1, s2): ddlog_std::Set<'X>)
}
function ddlog_std::unions (sets: ddlog_std::Vec<ddlog_std::Set<'X>>): ddlog_std::Set<'X>
{
    (ddlog_std::set_unions(sets): ddlog_std::Set<'X>)
}
function ddlog_std::unwrap_or (x: ddlog_std::Option<'A>, def: 'A): 'A
{
    match (x) {
        (ddlog_std::Some{.x=(var v: 'A)}: ddlog_std::Option<'A>) -> v,
        (ddlog_std::None{}: ddlog_std::Option<'A>) -> def
    }
}
function ddlog_std::unwrap_or (res: ddlog_std::Result<'V,'E>, def: 'V): 'V
{
    match (res) {
        (ddlog_std::Ok{.res=(var v: 'V)}: ddlog_std::Result<'V,'E>) -> v,
        (ddlog_std::Err{.err=(_: 'E)}: ddlog_std::Result<'V,'E>) -> def
    }
}
function ddlog_std::unwrap_or_default (opt: ddlog_std::Option<'A>): 'A
{
    (ddlog_std::option_unwrap_or_default(opt): 'A)
}
function ddlog_std::unwrap_or_default (res: ddlog_std::Result<'V,'E>): 'V
{
    (ddlog_std::result_unwrap_or_default(res): 'V)
}
function ddlog_std::update_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: 'X): bool
{
    ddlog_std::vec_update_nth(v, idx, value)
}
extern function ddlog_std::vec_append (v: mut ddlog_std::Vec<'X>, other: ddlog_std::Vec<'X>): ()
extern function ddlog_std::vec_contains (v: ddlog_std::Vec<'X>, x: 'X): bool
extern function ddlog_std::vec_empty (): ddlog_std::Vec<'A>
extern function ddlog_std::vec_is_empty (v: ddlog_std::Vec<'X>): bool
extern function ddlog_std::vec_len (v: ddlog_std::Vec<'X>): ddlog_std::usize
extern function ddlog_std::vec_nth (v: ddlog_std::Vec<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
extern function ddlog_std::vec_push (v: mut ddlog_std::Vec<'X>, x: 'X): ()
extern function ddlog_std::vec_push_imm (v: ddlog_std::Vec<'X>, x: 'X): ddlog_std::Vec<'X>
extern function ddlog_std::vec_resize (v: mut ddlog_std::Vec<'X>, new_len: ddlog_std::usize, value: 'X): ()
extern function ddlog_std::vec_set_nth (v: ddlog_std::Vec<'X>, n: ddlog_std::usize, value: 'X): ()
extern function ddlog_std::vec_singleton (x: 'X): ddlog_std::Vec<'X>
extern function ddlog_std::vec_sort (v: mut ddlog_std::Vec<'X>): ()
extern function ddlog_std::vec_sort_imm (v: ddlog_std::Vec<'X>): ddlog_std::Vec<'X>
extern function ddlog_std::vec_swap_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: mut 'X): bool
extern function ddlog_std::vec_to_set (s: ddlog_std::Vec<'A>): ddlog_std::Set<'A>
extern function ddlog_std::vec_update_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: 'X): bool
extern function ddlog_std::vec_with_capacity (len: ddlog_std::usize): ddlog_std::Vec<'A>
extern function ddlog_std::vec_with_length (len: ddlog_std::usize, x: 'A): ddlog_std::Vec<'A>
extern function debug::debug_event (operator_id: debug::DDlogOpId, w: ddlog_std::DDWeight, ts: 'T1, operator_type: string, input1: 'A1, out: 'A2): ()
extern function debug::debug_event_join (operator_id: debug::DDlogOpId, w: ddlog_std::DDWeight, ts: 'T1, input1: 'A1, input2: 'A2, out: 'A3): ()
extern function debug::debug_split_group (g: ddlog_std::Group<'K,('I, 'V)>): (ddlog_std::Vec<'I>, ddlog_std::Group<'K,'V>)
function evens (vec: ddlog_std::Vec<bigint>): ddlog_std::Vec<bigint>
{
    {(var res: ddlog_std::Vec<bigint>) = (ddlog_std::vec_empty(): ddlog_std::Vec<bigint>);
     {for (x in vec) {
          {if ((x % 2) != 0) {
               (continue: ())
           } else {
                 ()
             };
           {ddlog_std::vec_push(res, x);
            ()}}
      };
      res}}
}
function get_price_in_cents (inventory: ddlog_std::Map<string,string>, item: string): ddlog_std::Option<ddlog_std::u64>
{
    match ((ddlog_std::get(inventory, item): ddlog_std::Option<string>)) {
        (ddlog_std::None{}: ddlog_std::Option<string>) -> (ddlog_std::None{}: ddlog_std::Option<bit<64>>),
        (ddlog_std::Some{.x=(var price: string)}: ddlog_std::Option<string>) -> match (ddlog_std::parse_dec_u64(price)) {
                                                                                    (ddlog_std::None{}: ddlog_std::Option<bit<64>>) -> (ddlog_std::None{}: ddlog_std::Option<bit<64>>),
                                                                                    (ddlog_std::Some{.x=(var p: bit<64>)}: ddlog_std::Option<bit<64>>) -> (ddlog_std::Some{.x=(64'd100 * p)}: ddlog_std::Option<bit<64>>)
                                                                                }
    }
}
function get_price_in_cents_ (inventory: ddlog_std::Map<string,string>, item: string): ddlog_std::Option<ddlog_std::u64>
{
    (ddlog_std::Some{.x=(match (ddlog_std::parse_dec_u64(match ((ddlog_std::get(inventory, item): ddlog_std::Option<string>)) {
                                                             (ddlog_std::None{}: ddlog_std::Option<string>) -> ((return (ddlog_std::None{}: ddlog_std::Option<ddlog_std::u64>)): string),
                                                             (ddlog_std::Some{.x=(var __x: string)}: ddlog_std::Option<string>) -> __x
                                                         })) {
                             (ddlog_std::None{}: ddlog_std::Option<bit<64>>) -> ((return (ddlog_std::None{}: ddlog_std::Option<ddlog_std::u64>)): bit<64>),
                             (ddlog_std::Some{.x=(var __x: bit<64>)}: ddlog_std::Option<bit<64>>) -> __x
                         } * 64'd100)}: ddlog_std::Option<bit<64>>)
}
function get_price_in_cents_unwrap (inventory: ddlog_std::Map<string,string>, item: string): ddlog_std::u64
{
    ((ddlog_std::unwrap_or(ddlog_std::parse_dec_u64((ddlog_std::unwrap_or_default((ddlog_std::get(inventory, item): ddlog_std::Option<string>)): string)), 64'd0): bit<64>) * 64'd100)
}
#[has_side_effects = true]
extern function inspect_log::log (filename: string, msg: string): ()
function internment::contains (s1: internment::istring, s2: string): bool
{
    internment::istring_contains(s1, s2)
}
function internment::ends_with (s: internment::istring, suffix: string): bool
{
    internment::istring_ends_with(s, suffix)
}
extern function internment::intern (s: 'A): internment::Intern<'A>
extern function internment::istring_contains (s1: internment::istring, s2: string): bool
extern function internment::istring_ends_with (s: internment::istring, suffix: string): bool
extern function internment::istring_join (strings: ddlog_std::Vec<internment::istring>, sep: string): string
extern function internment::istring_len (s: internment::istring): ddlog_std::usize
extern function internment::istring_replace (s: internment::istring, from: string, to: string): string
extern function internment::istring_reverse (s: internment::istring): string
extern function internment::istring_split (s: internment::istring, sep: string): ddlog_std::Vec<string>
extern function internment::istring_starts_with (s: internment::istring, prefix: string): bool
extern function internment::istring_substr (s: internment::istring, start: ddlog_std::usize, end: ddlog_std::usize): string
extern function internment::istring_to_bytes (s: internment::istring): ddlog_std::Vec<ddlog_std::u8>
extern function internment::istring_to_lowercase (s: internment::istring): string
extern function internment::istring_to_uppercase (s: internment::istring): string
extern function internment::istring_trim (s: internment::istring): string
#[return_by_ref = true]
extern function internment::ival (s: internment::Intern<'A>): 'A
function internment::join (strings: ddlog_std::Vec<internment::istring>, sep: string): string
{
    internment::istring_join(strings, sep)
}
function internment::len (s: internment::istring): ddlog_std::usize
{
    internment::istring_len(s)
}
function internment::replace (s: internment::istring, from: string, to: string): string
{
    internment::istring_replace(s, from, to)
}
function internment::reverse (s: internment::istring): string
{
    internment::istring_reverse(s)
}
function internment::split (s: internment::istring, sep: string): ddlog_std::Vec<string>
{
    internment::istring_split(s, sep)
}
function internment::starts_with (s: internment::istring, prefix: string): bool
{
    internment::istring_starts_with(s, prefix)
}
function internment::substr (s: internment::istring, start: ddlog_std::usize, end: ddlog_std::usize): string
{
    internment::istring_substr(s, start, end)
}
function internment::to_bytes (s: internment::istring): ddlog_std::Vec<ddlog_std::u8>
{
    internment::istring_to_bytes(s)
}
function internment::to_lowercase (s: internment::istring): string
{
    internment::istring_to_lowercase(s)
}
function internment::to_string (s: internment::istring): string
{
    (internment::ival(s): string)
}
function internment::to_uppercase (s: internment::istring): string
{
    internment::istring_to_uppercase(s)
}
function internment::trim (s: internment::istring): string
{
    internment::istring_trim(s)
}
function inventory (): ddlog_std::Map<string,string>
{
    (ddlog_std::insert_imm((ddlog_std::map_singleton("Falcon 9", "62000000"): ddlog_std::Map<string,string>), "Soyuz", "180000000"): ddlog_std::Map<string,string>)
}
function ip_from_bytes (b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>): ip_addr_t
{
    (IPAddr{.addr=(((b3 ++ b2) ++ b1) ++ b0)}: ip_addr_t)
}
function is_multicast_addr (ip: ip_addr_t): bool
{
    (ip.addr[31:28] == 4'd14)
}
function is_target_audience (person: Person): bool
{
    ((person.nationality == "USA") and (person.occupation == "student"))
}
#[has_side_effects = true]
extern function log::log (module: log::module_t, level: log::log_level_t, msg: string): ()
function pkt_ip4 (pkt: eth_pkt_t): ip4_pkt_t
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(var ip4: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> ip4,
        (_: eth_pkt_t) -> (IP4Pkt{.ttl=8'd0, .src=32'd0, .dst=32'd0, .payload=(IPOther{}: ip_payload_t)}: ip4_pkt_t)
    }
}
function pkt_ip4_ (pkt: eth_pkt_t): ddlog_std::Option<ip4_pkt_t>
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(var ip4: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> (ddlog_std::Some{.x=ip4}: ddlog_std::Option<ip4_pkt_t>),
        (_: eth_pkt_t) -> (ddlog_std::None{}: ddlog_std::Option<ip4_pkt_t>)
    }
}
function pkt_udp_port (pkt: eth_pkt_t): bit<16>
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(IP4Pkt{.ttl=(_: bit<8>), .src=(_: bit<32>), .dst=(_: bit<32>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> port,
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=(_: bit<8>), .src=(_: bit<128>), .dst=(_: bit<128>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> port,
        (_: eth_pkt_t) -> 16'd0
    }
}
function pkt_udp_port2 (pkt: eth_pkt_t): ddlog_std::Option<bit<16>>
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(IP4Pkt{.ttl=(_: bit<8>), .src=(_: bit<32>), .dst=(_: bit<32>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> (ddlog_std::Some{.x=port}: ddlog_std::Option<bit<16>>),
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=(_: bit<8>), .src=(_: bit<128>), .dst=(_: bit<128>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> (ddlog_std::Some{.x=port}: ddlog_std::Option<bit<16>>),
        (_: eth_pkt_t) -> (ddlog_std::None{}: ddlog_std::Option<bit<16>>)
    }
}
function prefixBefore (vec: ddlog_std::Vec<'A>, v: 'A): ddlog_std::Vec<'A>
{
    {(var res: ddlog_std::Vec<'A>) = (ddlog_std::vec_empty(): ddlog_std::Vec<'A>);
     {for (x in vec) {
          {if (x == v) {
               (break: ())
           } else {
                 ()
             };
           {ddlog_std::vec_push(res, x);
            ()}}
      };
      res}}
}
function split_ip_list (x: string): ddlog_std::Vec<string>
{
    ddlog_std::split(x, " ")
}
extern function string_slice_unsafe (x: string, from: bit<64>, to: bit<64>): string
function tcp6_packet (ethsrc: bit<48>, ethdst: bit<48>, ipsrc: ip6_addr_t, ipdst: ip6_addr_t, srcport: bit<16>, dstport: bit<16>): eth_pkt_t
{
    (EthPacket{.src=ethsrc, .dst=ethdst, .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=8'd10, .src=ipsrc, .dst=ipdst, .payload=(IPTCP{.tcp=(TCPPkt{.src=srcport, .dst=dstport, .flags=9'd0}: tcp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t)
}
function to_string (ip: ip_addr_t): string
{
    ((((((("" ++ (ddlog_std::__builtin_2string(ip.addr[31:24]): string)) ++ ".") ++ (ddlog_std::__builtin_2string(ip.addr[23:16]): string)) ++ ".") ++ (ddlog_std::__builtin_2string(ip.addr[15:8]): string)) ++ ".") ++ (ddlog_std::__builtin_2string(ip.addr[7:0]): string))
}
function to_string (mac: mac_addr_t): string
{
    ((((((((((("" ++ ddlog_std::hex(mac.addr[47:40])) ++ ":") ++ ddlog_std::hex(mac.addr[39:32])) ++ ":") ++ ddlog_std::hex(mac.addr[31:24])) ++ ":") ++ ddlog_std::hex(mac.addr[23:16])) ++ ":") ++ ddlog_std::hex(mac.addr[15:8])) ++ ":") ++ ddlog_std::hex(mac.addr[7:0]))
}
function to_string (h: nethost_t): string
{
    ((("Host: IP=" ++ (to_string(h.ip): string)) ++ ", MAC=") ++ (to_string(h.mac): string))
}
function vsep (strs: ddlog_std::Vec<string>): string
{
    {(var res: string) = "";
     {for (s in strs) {
          {res = ((res ++ s) ++ "\n");
           ()}
      };
      res}}
}
output relation Address [Address]
input relation Author [Author]
output relation BestDeal [BestDeal]
output relation BestPrice [BestPrice]
output relation BestVendor [BestVendor]
input relation Blacklisted [Blacklisted]
output relation BookByAuthor [BookByAuthor]
input relation Bytes [Bytes]
input relation Endpoint [Endpoint]
output relation EndpointString [EndpointString]
output relation Evens [Evens]
input relation EvensAndOdds [EvensAndOdds]
output relation First5 [First5]
output relation Flow [Flow]
output relation Flow1 [Flow1]
input relation Host [Host]
input relation HostAddress [HostAddress]
output relation HostIP [HostIP]
output relation HostIPVSep [HostIPVSep]
output relation HostInSubnet [HostInSubnet]
output relation IntranetHost [IntranetHost]
output relation IntranetHost2 [IntranetHost2]
output relation IntranetHost3 [IntranetHost3]
output relation InventoryItemName [InventoryItemName]
output relation ItemInOrders [ItemInOrders]
input relation KnownHost [KnownHost]
input relation Library [Library]
input relation Load_Balancer [Load_Balancer]
input relation Logical_Switch [Logical_Switch]
output relation MCastAddress [MCastAddress]
input multiset MSetIn [MSetIn]
output multiset MSetOut [MSetOut]
output relation MilkOrders [MilkOrders]
input relation NetHost [NetHost]
output relation NetHostString [NetHostString]
input relation Number [Number]
input relation OnlineOrder [OnlineOrder]
output relation OrderFormatted [OrderFormatted]
input relation Packet [Packet]
input relation Person [Person]
output relation Phrases [Phrases]
output relation Pow2 [Pow2]
output relation Prefix [Prefix]
input relation Price [Price]
output relation PriceInCents [PriceInCents]
output relation Product [Product]
output relation SanitizedEndpoint [SanitizedEndpoint]
input relation School [ddlog_std::Ref<School>]
input relation StoreInventory [StoreInventory]
input relation Student [ddlog_std::Ref<Student>]
relation StudentInfo [StudentInfo]
input relation Subnet [Subnet]
output relation Sum [Sum]
output relation TCPDstPort [TCPDstPort]
output relation TargetAudience [Person]
output relation TopScore [TopScore]
output relation UDPDstPort [UDPDstPort]
output relation UDPDstPort2 [UDPDstPort2]
input relation Vector [Vector]
input relation Word1 [Word1]
input relation Word2 [Word2]
output relation WorstPrice [WorstPrice]
input relation X [X]
Phrases[(Phrases{.phrase=((w1 ++ " ") ++ w2)}: Phrases)] :- Word1[(__word10@ (Word1{.word=(w1: string), .cat=(cat: Category)}: Word1))], Word2[(__word21@ (Word2{.word=(w2: string), .cat=(cat: Category)}: Word2))], Inspect debug::debug_event_join((32'd0, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __word10, __word21, (Phrases{.phrase=((w1 ++ " ") ++ w2)}: Phrases)).
Word1[(Word1{.word="Hello,", .cat=(CategoryOther{}: Category)}: Word1)].
Word2[(Word2{.word="World!", .cat=(CategoryOther{}: Category)}: Word2)].
HostInSubnet[(HostInSubnet{.host=host_id, .subnet=subnet_id}: HostInSubnet)] :- Host[(__host0@ (Host{.id=(host_id: bit<128>), .name=(_: string), .ip=(host_ip: bit<32>)}: Host))], Subnet[(__subnet1@ (Subnet{.id=(subnet_id: bit<128>), .prefix=(subnet_prefix: bit<32>), .mask=(subnet_mask: bit<32>)}: Subnet))], Inspect debug::debug_event_join((32'd3, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __host0, __subnet1, (host_id, host_ip, subnet_id, subnet_prefix, subnet_mask)), ((host_ip & subnet_mask) == subnet_prefix), Inspect debug::debug_event((32'd3, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (host_id, host_ip, subnet_id, subnet_prefix, subnet_mask), (HostInSubnet{.host=host_id, .subnet=subnet_id}: HostInSubnet)).
Pow2[(Pow2{.p=((("The square of " ++ (ddlog_std::__builtin_2string(x): string)) ++ " is ") ++ (ddlog_std::__builtin_2string((x * x)): string))}: Pow2)] :- Number[(__number0@ (Number{.n=(x: bigint)}: Number))], Inspect debug::debug_event((32'd4, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __number0, (Pow2{.p=((("The square of " ++ (ddlog_std::__builtin_2string(x): string)) ++ " is ") ++ (ddlog_std::__builtin_2string((x * x)): string))}: Pow2)).
NetHostString[(NetHostString{.id=id, .s=("" ++ (to_string(h): string))}: NetHostString)] :- NetHost[(__nethost0@ (NetHost{.id=(id: bigint), .h=(h: nethost_t)}: NetHost))], Inspect debug::debug_event((32'd5, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __nethost0, (NetHostString{.id=id, .s=("" ++ (to_string(h): string))}: NetHostString)).
Address[(Address{.addr=ip_from_bytes(b3, b2, b1, b0)}: Address)] :- Bytes[(__bytes0@ (Bytes{.b3=(b3: bit<8>), .b2=(b2: bit<8>), .b1=(b1: bit<8>), .b0=(b0: bit<8>)}: Bytes))], Inspect debug::debug_event((32'd6, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __bytes0, (Address{.addr=ip_from_bytes(b3, b2, b1, b0)}: Address)).
MCastAddress[(MCastAddress{.addr=a}: MCastAddress)] :- Address[(__address0@ (Address{.addr=(a: ip_addr_t)}: Address))], is_multicast_addr(a), Inspect debug::debug_event((32'd7, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __address0, (MCastAddress{.addr=a}: MCastAddress)).
EndpointString[(EndpointString{.s=addr_port(ip, proto, preferred_port)}: EndpointString)] :- Endpoint[(__endpoint0@ (Endpoint{.ip=(ip: ip_addr_t), .proto=(proto: string), .preferred_port=(preferred_port: bit<16>)}: Endpoint))], Inspect debug::debug_event((32'd8, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __endpoint0, (EndpointString{.s=addr_port(ip, proto, preferred_port)}: EndpointString)).
First5[(First5{.str=string_slice_unsafe(p, 64'd0, 64'd5)}: First5)] :- Phrases[(__phrases0@ (Phrases{.phrase=(p: string)}: Phrases))], Inspect debug::debug_event((32'd9, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __phrases0, (First5{.str=string_slice_unsafe(p, 64'd0, 64'd5)}: First5)).
SanitizedEndpoint[(SanitizedEndpoint{.ep=endpoint}: SanitizedEndpoint)] :- Endpoint[(__endpoint0@ (Endpoint{.ip=(ip: ip_addr_t), .proto=(proto: string), .preferred_port=(preferred_port: bit<16>)}: Endpoint))], (var endpoint: string) = addr_port(ip, proto, preferred_port), Inspect debug::debug_event((32'd10, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __endpoint0, endpoint), not Blacklisted[(Blacklisted{.ep=(endpoint: string)}: Blacklisted)], Inspect debug::debug_event((32'd10, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Antijoin", endpoint, (SanitizedEndpoint{.ep=endpoint}: SanitizedEndpoint)).
BookByAuthor[(BookByAuthor{.book=b, .author=author}: BookByAuthor)] :- Library[(__library0@ (Library{.book=(b@ (Book{.author=(author_name: string), .title=(_: string)}: Book))}: Library))], Author[(author@ (Author{.name=(author_name: string), .born=(_: bit<32>)}: Author))], Inspect debug::debug_event_join((32'd11, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __library0, author, (BookByAuthor{.book=b, .author=author}: BookByAuthor)).
HostIP[(HostIP{.host=host, .addr=addr}: HostIP)] :- HostAddress[(__hostaddress0@ (HostAddress{.host=(host: bit<64>), .addrs=(addrs: string)}: HostAddress))], var addr = FlatMap(split_ip_list(addrs)), Inspect debug::debug_event((32'd12, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Flatmap", __hostaddress0, (HostIP{.host=host, .addr=addr}: HostIP)).
HostIPVSep[(HostIPVSep{.host=host, .addrs=vaddrs}: HostIPVSep)] :- HostAddress[(__hostaddress0@ (HostAddress{.host=(host: bit<64>), .addrs=(addrs: string)}: HostAddress))], (var vaddrs: string) = vsep(split_ip_list(addrs)), Inspect debug::debug_event((32'd13, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __hostaddress0, (HostIPVSep{.host=host, .addrs=vaddrs}: HostIPVSep)).
Evens[(Evens{.evens_and_odds=vec, .evens=evens(vec)}: Evens)] :- EvensAndOdds[(__evensandodds0@ (EvensAndOdds{.vec=(vec: ddlog_std::Vec<bigint>)}: EvensAndOdds))], Inspect debug::debug_event((32'd14, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __evensandodds0, (Evens{.evens_and_odds=vec, .evens=evens(vec)}: Evens)).
Prefix[(Prefix{.vec=(prefixBefore(vec, sep): ddlog_std::Vec<string>)}: Prefix)] :- Vector[(__vector0@ (Vector{.vec=(vec: ddlog_std::Vec<string>), .sep=(sep: string)}: Vector))], Inspect debug::debug_event((32'd15, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __vector0, (Prefix{.vec=(prefixBefore(vec, sep): ddlog_std::Vec<string>)}: Prefix)).
Sum[(Sum{.x=x, .y=y, .sum=(x + y)}: Sum)],
Product[(Product{.x=x, .y=y, .prod=(x * y)}: Product)] :- X[(__x0@ (X{.x=(x: bit<16>)}: X))], X[(__x1@ (X{.x=(y: bit<16>)}: X))], Inspect debug::debug_event_join((32'd16, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __x0, __x1, (Sum{.x=x, .y=y, .sum=(x + y)}: Sum)), Inspect debug::debug_event_join((32'd16, 32'd1, 32'd1), ddlog_weight, ddlog_timestamp, __x0, __x1, (Product{.x=x, .y=y, .prod=(x * y)}: Product)).
BestPrice[(BestPrice{.item=item, .price=best_price}: BestPrice)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(_: string), .price=(price: bit<64>)}: Price))], var __inputs_best_price = Aggregate(item, ddlog_std::__debug_17_1_group_min((__price0, price))), Inspect debug::debug_event((32'd17, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best_price.0, (__inputs_best_price, item)), (var best_price: bit<64>) = __inputs_best_price.1, Inspect debug::debug_event((32'd17, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_best_price, item), (BestPrice{.item=item, .price=best_price}: BestPrice)).
WorstPrice[(WorstPrice{.item=item, .price=best_price}: WorstPrice)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(_: string), .price=(price: bit<64>)}: Price))], var __inputs_best_price = Aggregate(item, ddlog_std::__debug_18_1_group_max((__price0, price))), Inspect debug::debug_event((32'd18, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best_price.0, (__inputs_best_price, item)), (var best_price: bit<64>) = __inputs_best_price.1, Inspect debug::debug_event((32'd18, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_best_price, item), (WorstPrice{.item=item, .price=best_price}: WorstPrice)).
BestVendor[(BestVendor{.item=item, .vendor=best_vendor, .price=best_price}: BestVendor)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(vendor: string), .price=(price: bit<64>)}: Price))], var __inputs_best_vendor_price = Aggregate(item, __debug_19_1_best_vendor((__price0, (vendor, price)))), Inspect debug::debug_event((32'd19, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best_vendor_price.0, (__inputs_best_vendor_price, item)), (var best_vendor_price: (string, bit<64>)) = __inputs_best_vendor_price.1, ((var best_vendor: string), (var best_price: bit<64>)) = best_vendor_price, Inspect debug::debug_event((32'd19, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (item, best_vendor_price), (BestVendor{.item=item, .vendor=best_vendor, .price=best_price}: BestVendor)).
BestDeal[(BestDeal{.best=best}: BestDeal)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(vendor: string), .price=(price: bit<64>)}: Price))], Inspect inspect_log::log("../tutorial.log", (((((((((("ts:" ++ (ddlog_std::__builtin_2string(ddlog_timestamp): string)) ++ ", w:") ++ (ddlog_std::__builtin_2string(ddlog_weight): string)) ++ ": Price(item=\"") ++ item) ++ "\", vendor=\"") ++ vendor) ++ "\", price=") ++ (ddlog_std::__builtin_2string(price): string)) ++ ")")), Inspect debug::debug_event((32'd20, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Inspect", __price0, (__price0, item, vendor, price)), var __inputs_best = Aggregate(item, __debug_20_2_best_vendor_string(((__price0, item, vendor, price), (vendor, price)))), Inspect debug::debug_event((32'd20, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best.0, (__inputs_best, item)), (var best: string) = __inputs_best.1, Inspect debug::debug_event((32'd20, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_best, item), (item, best)), Inspect inspect_log::log("../tutorial.log", (((((((("ts:" ++ (ddlog_std::__builtin_2string(ddlog_timestamp): string)) ++ ", w:") ++ (ddlog_std::__builtin_2string(ddlog_weight): string)) ++ ": best(\"") ++ item) ++ "\")=\"") ++ best) ++ "\"")), Inspect debug::debug_event((32'd20, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, "Inspect", (item, best), (BestDeal{.best=best}: BestDeal)).
MSetOut[(MSetOut{.x=x}: MSetOut)] :- MSetIn[(__msetin0@ (MSetIn{.x=(x: bit<32>)}: MSetIn))], Inspect debug::debug_event((32'd21, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __msetin0, (MSetOut{.x=x}: MSetOut)).
TCPDstPort[(TCPDstPort{.port=port}: TCPDstPort)] :- Packet[(__packet0@ (Packet{.pkt=(EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(IP4Pkt{.ttl=(_: bit<8>), .src=(_: bit<32>), .dst=(_: bit<32>), .payload=(IPTCP{.tcp=(TCPPkt{.src=(_: bit<16>), .dst=(port: bit<16>), .flags=(_: bit<9>)}: tcp_pkt_t)}: ip_payload_t)}: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t)}: Packet))], Inspect debug::debug_event((32'd22, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __packet0, (TCPDstPort{.port=port}: TCPDstPort)).
TCPDstPort[(TCPDstPort{.port=port}: TCPDstPort)] :- Packet[(__packet0@ (Packet{.pkt=(EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=(_: bit<8>), .src=(_: bit<128>), .dst=(_: bit<128>), .payload=(IPTCP{.tcp=(TCPPkt{.src=(_: bit<16>), .dst=(port: bit<16>), .flags=(_: bit<9>)}: tcp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t)}: Packet))], Inspect debug::debug_event((32'd23, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __packet0, (TCPDstPort{.port=port}: TCPDstPort)).
UDPDstPort[(UDPDstPort{.port=port}: UDPDstPort)] :- Packet[(__packet0@ (Packet{.pkt=(pkt: eth_pkt_t)}: Packet))], (var port: bit<16>) = pkt_udp_port(pkt), (port != 16'd0), Inspect debug::debug_event((32'd24, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", port, (UDPDstPort{.port=port}: UDPDstPort)).
UDPDstPort2[(UDPDstPort2{.port=port}: UDPDstPort2)] :- Packet[(__packet0@ (Packet{.pkt=(pkt: eth_pkt_t)}: Packet))], (ddlog_std::Some{.x=(var port: bit<16>)}: ddlog_std::Option<bit<16>>) = pkt_udp_port2(pkt), Inspect debug::debug_event((32'd25, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __packet0, (UDPDstPort2{.port=port}: UDPDstPort2)).
IntranetHost[(IntranetHost{.addr=addr}: IntranetHost)] :- KnownHost[(__knownhost0@ (KnownHost{.addr=(addr: bit<32>)}: KnownHost))], ((var b3: bit<8>), (var b2: bit<8>), (_: bit<8>), (_: bit<8>)) = addr_to_tuple(addr), (b3 == 8'd192), (b2 == 8'd168), Inspect debug::debug_event((32'd26, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (addr, b2), (IntranetHost{.addr=addr}: IntranetHost)).
IntranetHost2[(IntranetHost2{.addr=addr}: IntranetHost2)] :- KnownHost[(__knownhost0@ (KnownHost{.addr=(addr: bit<32>)}: KnownHost))], (8'd192, 8'd168, (_: bit<8>), (_: bit<8>)) = addr_to_tuple(addr), Inspect debug::debug_event((32'd27, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __knownhost0, (IntranetHost2{.addr=addr}: IntranetHost2)).
IntranetHost3[(IntranetHost3{.addr=addr}: IntranetHost3)] :- KnownHost[(__knownhost0@ (KnownHost{.addr=(addr: bit<32>)}: KnownHost))], (var t: (bit<8>, bit<8>, bit<8>, bit<8>)) = addr_to_tuple(addr), (t.0 == 8'd192), (t.1 == 8'd168), Inspect debug::debug_event((32'd28, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (addr, t), (IntranetHost3{.addr=addr}: IntranetHost3)).
PriceInCents[(PriceInCents{.item="Falcon 9", .price1=get_price_in_cents(inventory(), "Falcon 9"), .price2=get_price_in_cents_unwrap(inventory(), "Falcon 9"), .price3=get_price_in_cents_(inventory(), "Falcon 9")}: PriceInCents)].
PriceInCents[(PriceInCents{.item="Atlantis", .price1=get_price_in_cents(inventory(), "Atlantis"), .price2=get_price_in_cents_unwrap(inventory(), "Atlantis"), .price3=get_price_in_cents_(inventory(), "Atlantis")}: PriceInCents)].
TargetAudience[person] :- Person[(__person0@ (person: Person))], is_target_audience(person), Inspect debug::debug_event((32'd31, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __person0, person).
StudentInfo[(StudentInfo{.student=student, .school=school}: StudentInfo)] :- Student[(student@ ((&(Student{.id=(_: bit<64>), .name=(_: string), .school=(school_name: string), .sat_score=(_: bit<16>)}: Student)): ddlog_std::Ref<Student>))], School[(school@ ((&(School{.name=(school_name: string), .address=(_: string)}: School)): ddlog_std::Ref<School>))], Inspect debug::debug_event_join((32'd32, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, student, school, (StudentInfo{.student=student, .school=school}: StudentInfo)).
TopScore[(TopScore{.school=school, .top_score=top_score}: TopScore)] :- StudentInfo[(__studentinfo0@ (StudentInfo{.student=((&(Student{.id=(_: bit<64>), .name=(_: string), .school=(_: string), .sat_score=(sat: bit<16>)}: Student)): ddlog_std::Ref<Student>), .school=((&(School{.name=(school: string), .address=(_: string)}: School)): ddlog_std::Ref<School>)}: StudentInfo))], var __inputs_top_score = Aggregate(school, ddlog_std::__debug_33_1_group_max((__studentinfo0, sat))), Inspect debug::debug_event((32'd33, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_top_score.0, (__inputs_top_score, school)), (var top_score: bit<16>) = __inputs_top_score.1, Inspect debug::debug_event((32'd33, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_top_score, school), (TopScore{.school=school, .top_score=top_score}: TopScore)).
TopScore[(TopScore{.school=school, .top_score=top_score}: TopScore)] :- StudentInfo[(__studentinfo0@ (StudentInfo{.student=(student: ddlog_std::Ref<Student>), .school=((&(School{.name=(school: string), .address=(_: string)}: School)): ddlog_std::Ref<School>)}: StudentInfo))], var __inputs_top_score = Aggregate(school, ddlog_std::__debug_34_1_group_max((__studentinfo0, student.sat_score))), Inspect debug::debug_event((32'd34, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_top_score.0, (__inputs_top_score, school)), (var top_score: bit<16>) = __inputs_top_score.1, Inspect debug::debug_event((32'd34, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_top_score, school), (TopScore{.school=school, .top_score=top_score}: TopScore)).
ItemInOrders[(ItemInOrders{.item=(internment::ival(item): string), .orders=orders}: ItemInOrders)] :- OnlineOrder[(__onlineorder0@ (OnlineOrder{.order_id=(order: bit<64>), .item=(item: internment::Intern<string>)}: OnlineOrder))], var __inputs_orders = Aggregate(item, ddlog_std::__debug_35_1_group_to_vec((__onlineorder0, order))), Inspect debug::debug_event((32'd35, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_orders.0, (__inputs_orders, item)), (var orders: ddlog_std::Vec<bit<64>>) = __inputs_orders.1, Inspect debug::debug_event((32'd35, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_orders, item), (ItemInOrders{.item=(internment::ival(item): string), .orders=orders}: ItemInOrders)).
OrderFormatted[(OrderFormatted{.order=formatted}: OrderFormatted)] :- OnlineOrder[(__onlineorder0@ (OnlineOrder{.order_id=(order: bit<64>), .item=(item: internment::Intern<string>)}: OnlineOrder))], (var formatted: string) = ((("order: " ++ (ddlog_std::__builtin_2string(order): string)) ++ ", item: ") ++ (internment::ival(item): string)), Inspect debug::debug_event((32'd36, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __onlineorder0, (OrderFormatted{.order=formatted}: OrderFormatted)).
MilkOrders[(MilkOrders{.order=order}: MilkOrders)] :- OnlineOrder[(__onlineorder0@ (OnlineOrder{.order_id=(order: bit<64>), .item=(internment::intern("milk"): internment::Intern<string>)}: OnlineOrder))], Inspect debug::debug_event((32'd37, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __onlineorder0, (MilkOrders{.order=order}: MilkOrders)).
InventoryItemName[(InventoryItemName{.name=name}: InventoryItemName)] :- StoreInventory[(__storeinventory0@ (StoreInventory{.item=(item: internment::Intern<StoreItem>)}: StoreInventory))], (var name: string) = (internment::ival(item): StoreItem).name, Inspect debug::debug_event((32'd38, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __storeinventory0, (InventoryItemName{.name=name}: InventoryItemName)).
Flow[(Flow{.lr=ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ addresses), .actionStr="{ reg0[0] = 1; next; }"}: Flow)] :- Load_Balancer[(__load_balancer0@ (Load_Balancer{.lb=(_: bigint), .ls=(ls: bigint), .ip_addresses=(addresses: string), .protocol=(ddlog_std::Some{.x=(_: string)}: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], Inspect debug::debug_event((32'd39, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __load_balancer0, (Flow{.lr=ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ addresses), .actionStr="{ reg0[0] = 1; next; }"}: Flow)).
Flow[(Flow{.lr=ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow)] :- Logical_Switch[(__logical_switch0@ (Logical_Switch{.ls=(ls: bigint)}: Logical_Switch))], Load_Balancer[(__load_balancer1@ (Load_Balancer{.lb=(_: bigint), .ls=(ls: bigint), .ip_addresses=(_: string), .protocol=(_: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], Inspect debug::debug_event_join((32'd40, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __logical_switch0, __load_balancer1, (Flow{.lr=ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow)).
Flow1[(Flow1{.lr=lb.ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ a), .actionStr="{ reg0[0] = 1; next; }"}: Flow1)] :- Load_Balancer[(lb@ (Load_Balancer{.lb=(_: bigint), .ls=(_: bigint), .ip_addresses=(_: string), .protocol=(_: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], (var a: string) = lb.ip_addresses, match (lb.protocol) {
                                                                                                                                                                                                                                                                                                                                                                          (ddlog_std::Some{.x=(_: string)}: ddlog_std::Option<string>) -> true,
                                                                                                                                                                                                                                                                                                                                                                          (ddlog_std::None{}: ddlog_std::Option<string>) -> false
                                                                                                                                                                                                                                                                                                                                                                      }, Inspect debug::debug_event((32'd41, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (lb, a), (Flow1{.lr=lb.ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ a), .actionStr="{ reg0[0] = 1; next; }"}: Flow1)).
Flow1[(Flow1{.lr=ls.ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow1)] :- Logical_Switch[(ls@ (Logical_Switch{.ls=(_: bigint)}: Logical_Switch))], Load_Balancer[(lb@ (Load_Balancer{.lb=(_: bigint), .ls=(_: bigint), .ip_addresses=(_: string), .protocol=(_: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], Inspect debug::debug_event_join((32'd42, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, ls, lb, (ls, lb)), (lb.ls == ls.ls), Inspect debug::debug_event((32'd42, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (ls, lb), (Flow1{.lr=ls.ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow1)).

